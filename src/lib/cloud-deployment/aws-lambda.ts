import { PromptConfig, DeploymentConfig } from '@/types';
import { DeploymentFiles } from './index';

function escapeString(str: string): string {
  return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
}

export function generateAWSLambdaDeployment(
  promptConfig: PromptConfig,
  deploymentConfig: DeploymentConfig
): DeploymentFiles {
  const promptTemplate = escapeString(promptConfig.prompt);

  const handlerCode = `/**
 * ${promptConfig.name} - AWS Lambda Handler
 * Generated by PromptStudio
 */

import { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';

// Prompt configuration
const PROMPT_TEMPLATE = \`${promptTemplate}\`;
const DEFAULT_MODEL = '${promptConfig.model}';
const DEFAULT_CONFIG = {
  temperature: ${promptConfig.temperature},
  max_tokens: ${promptConfig.maxTokens},
  top_p: ${promptConfig.topP},
  frequency_penalty: ${promptConfig.frequencyPenalty},
  presence_penalty: ${promptConfig.presencePenalty},
};

interface PromptVariables {
${promptConfig.variables.map(v => `  ${v.name}${v.required ? '' : '?'}: ${v.type === 'string' ? 'string' : v.type === 'number' ? 'number' : v.type === 'boolean' ? 'boolean' : 'unknown'};`).join('\n')}
}

interface RequestBody {
  variables?: PromptVariables;
  options?: {
    model?: string;
    temperature?: number;
    max_tokens?: number;
    top_p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
  };
}

function buildPrompt(variables: Record<string, unknown>): string {
  let prompt = PROMPT_TEMPLATE;
  for (const [key, value] of Object.entries(variables)) {
    prompt = prompt.replace(new RegExp(\`{{\\\\s*\${key}\\\\s*}}\`, 'g'), String(value));
  }
  return prompt;
}

function corsHeaders(): Record<string, string> {
  return {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Key',
    'Content-Type': 'application/json',
  };
}

${deploymentConfig.rateLimit?.enabled ? `
// Simple in-memory rate limiting (for production, use DynamoDB or ElastiCache)
const rateLimitStore = new Map<string, { count: number; resetAt: number }>();

function checkRateLimit(clientId: string): { allowed: boolean; retryAfter?: number } {
  const now = Date.now();
  const windowMs = 60000;
  const maxRequests = ${deploymentConfig.rateLimit.requestsPerMinute};

  const record = rateLimitStore.get(clientId);

  if (!record || now > record.resetAt) {
    rateLimitStore.set(clientId, { count: 1, resetAt: now + windowMs });
    return { allowed: true };
  }

  if (record.count >= maxRequests) {
    return { allowed: false, retryAfter: Math.ceil((record.resetAt - now) / 1000) };
  }

  record.count++;
  return { allowed: true };
}
` : ''}

${deploymentConfig.webhook?.enabled ? `
import * as crypto from 'crypto';

async function sendWebhook(event: string, data: Record<string, unknown>): Promise<void> {
  const webhookUrl = process.env.WEBHOOK_URL;
  const webhookSecret = process.env.WEBHOOK_SECRET || '';

  if (!webhookUrl) return;

  try {
    const payload = JSON.stringify({
      event,
      timestamp: new Date().toISOString(),
      data,
    });

    const signature = crypto
      .createHmac('sha256', webhookSecret)
      .update(payload)
      .digest('base64');

    await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': signature,
      },
      body: payload,
    });
  } catch (error) {
    console.error('Webhook error:', error);
  }
}
` : ''}

${deploymentConfig.apiKey?.enabled ? `
function validateApiKey(event: APIGatewayProxyEvent): boolean {
  const apiKey = event.headers['x-api-key'] ||
                 event.headers['X-API-Key'] ||
                 event.headers['authorization']?.replace('Bearer ', '') ||
                 event.headers['Authorization']?.replace('Bearer ', '');
  const validKeys = (process.env.API_KEYS || '').split(',').filter(Boolean);
  return validKeys.length === 0 || validKeys.includes(apiKey || '');
}
` : ''}

export async function handler(
  event: APIGatewayProxyEvent,
  context: Context
): Promise<APIGatewayProxyResult> {
  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: corsHeaders(),
      body: '',
    };
  }

  // GET - Return prompt info
  if (event.httpMethod === 'GET') {
    return {
      statusCode: 200,
      headers: corsHeaders(),
      body: JSON.stringify({
        name: '${promptConfig.name}',
        description: '${promptConfig.description || ''}',
        model: DEFAULT_MODEL,
        variables: ${JSON.stringify(promptConfig.variables.map(v => ({
          name: v.name,
          type: v.type,
          required: v.required,
          description: v.description
        })))},
      }),
    };
  }

  // POST - Execute prompt
  if (event.httpMethod === 'POST') {
    const startTime = Date.now();

    try {
      ${deploymentConfig.apiKey?.enabled ? `
      // Validate API key
      if (!validateApiKey(event)) {
        return {
          statusCode: 401,
          headers: corsHeaders(),
          body: JSON.stringify({ error: 'Invalid or missing API key' }),
        };
      }
      ` : ''}

      ${deploymentConfig.rateLimit?.enabled ? `
      // Check rate limit
      const clientId = event.requestContext.identity?.sourceIp || 'anonymous';
      const { allowed, retryAfter } = checkRateLimit(clientId);

      if (!allowed) {
        ${deploymentConfig.webhook?.enabled ? `await sendWebhook('rate_limit.exceeded', { clientId });` : ''}
        return {
          statusCode: 429,
          headers: { ...corsHeaders(), 'Retry-After': String(retryAfter) },
          body: JSON.stringify({ error: 'Rate limit exceeded' }),
        };
      }
      ` : ''}

      const body: RequestBody = JSON.parse(event.body || '{}');
      const { variables = {}, options = {} } = body;

      ${deploymentConfig.webhook?.enabled ? `await sendWebhook('request.started', { variables });` : ''}

      const prompt = buildPrompt(variables);

      const payload = {
        model: options.model || DEFAULT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        ...DEFAULT_CONFIG,
        ...options,
      };

      const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': \`Bearer \${process.env.OPENAI_API_KEY}\`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!openaiResponse.ok) {
        const error = await openaiResponse.json() as Record<string, unknown>;
        ${deploymentConfig.webhook?.enabled ? `await sendWebhook('request.failed', { error });` : ''}
        return {
          statusCode: openaiResponse.status,
          headers: corsHeaders(),
          body: JSON.stringify({
            error: (error.error as Record<string, unknown>)?.message || 'OpenAI API error'
          }),
        };
      }

      const data = await openaiResponse.json() as Record<string, unknown>;
      const latencyMs = Date.now() - startTime;

      const choices = data.choices as Array<Record<string, unknown>>;
      const usage = data.usage as Record<string, number>;

      const response = {
        content: (choices?.[0]?.message as Record<string, unknown>)?.content || '',
        model: data.model,
        usage: {
          promptTokens: usage?.prompt_tokens || 0,
          completionTokens: usage?.completion_tokens || 0,
          totalTokens: usage?.total_tokens || 0,
        },
        finishReason: choices?.[0]?.finish_reason || '',
        latencyMs,
      };

      ${deploymentConfig.webhook?.enabled ? `await sendWebhook('request.completed', { latencyMs, usage: response.usage });` : ''}

      return {
        statusCode: 200,
        headers: corsHeaders(),
        body: JSON.stringify(response),
      };
    } catch (error) {
      console.error('Error:', error);
      ${deploymentConfig.webhook?.enabled ? `await sendWebhook('error.occurred', { error: String(error) });` : ''}
      return {
        statusCode: 500,
        headers: corsHeaders(),
        body: JSON.stringify({ error: 'Internal server error' }),
      };
    }
  }

  return {
    statusCode: 405,
    headers: corsHeaders(),
    body: JSON.stringify({ error: 'Method not allowed' }),
  };
}
`;

  const samTemplate = `AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: ${promptConfig.name} - Generated by PromptStudio

Globals:
  Function:
    Timeout: ${deploymentConfig.timeout}
    MemorySize: ${deploymentConfig.memory}
    Runtime: nodejs20.x
    Architectures:
      - arm64

Parameters:
  OpenAIApiKey:
    Type: String
    NoEcho: true
    Description: OpenAI API Key
  ${deploymentConfig.webhook?.enabled ? `WebhookUrl:
    Type: String
    Description: Webhook URL for notifications
  WebhookSecret:
    Type: String
    NoEcho: true
    Description: Webhook signing secret` : ''}
  ${deploymentConfig.apiKey?.enabled ? `ApiKeys:
    Type: String
    NoEcho: true
    Description: Comma-separated list of valid API keys` : ''}

Resources:
  PromptFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: ${deploymentConfig.name}
      CodeUri: dist/
      Handler: handler.handler
      Environment:
        Variables:
          OPENAI_API_KEY: !Ref OpenAIApiKey
          ${deploymentConfig.webhook?.enabled ? `WEBHOOK_URL: !Ref WebhookUrl
          WEBHOOK_SECRET: !Ref WebhookSecret` : ''}
          ${deploymentConfig.apiKey?.enabled ? `API_KEYS: !Ref ApiKeys` : ''}
      Events:
        GetPrompt:
          Type: Api
          Properties:
            Path: /prompt
            Method: GET
        ExecutePrompt:
          Type: Api
          Properties:
            Path: /prompt
            Method: POST
        Options:
          Type: Api
          Properties:
            Path: /prompt
            Method: OPTIONS
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: "es2020"
        Sourcemap: true
        EntryPoints:
          - src/handler.ts

Outputs:
  ApiEndpoint:
    Description: API Gateway endpoint URL
    Value: !Sub "https://\${ServerlessRestApi}.execute-api.\${AWS::Region}.amazonaws.com/Prod/prompt"
  FunctionArn:
    Description: Lambda Function ARN
    Value: !GetAtt PromptFunction.Arn
`;

  const packageJson = `{
  "name": "${deploymentConfig.name}",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "esbuild src/handler.ts --bundle --platform=node --target=node20 --outdir=dist",
    "deploy": "sam build && sam deploy --guided",
    "local": "sam local start-api"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.131",
    "@types/node": "^20.0.0",
    "esbuild": "^0.19.0",
    "typescript": "^5.0.0"
  }
}`;

  const tsconfig = `{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}`;

  const samconfig = `version = 0.1

[default.deploy.parameters]
stack_name = "${deploymentConfig.name}"
region = "${deploymentConfig.region}"
confirm_changeset = true
capabilities = "CAPABILITY_IAM"
`;

  const readme = `# ${promptConfig.name} - AWS Lambda

This API endpoint is deployed on AWS Lambda with API Gateway.

## Prerequisites

- AWS CLI configured with appropriate credentials
- AWS SAM CLI installed

## Deployment

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Build the project:
   \`\`\`bash
   npm run build
   \`\`\`

3. Deploy (first time - will prompt for parameters):
   \`\`\`bash
   npm run deploy
   \`\`\`

   You'll be prompted for:
   - OpenAIApiKey: Your OpenAI API key
   ${deploymentConfig.webhook?.enabled ? '- WebhookUrl: URL for webhook notifications\n   - WebhookSecret: Secret for signing webhooks' : ''}
   ${deploymentConfig.apiKey?.enabled ? '- ApiKeys: Comma-separated list of valid API keys' : ''}

## Local Development

Run the API locally:
\`\`\`bash
npm run local
\`\`\`

## Usage

### Execute Prompt

\`\`\`bash
curl -X POST https://your-api-id.execute-api.${deploymentConfig.region}.amazonaws.com/Prod/prompt \\
  -H "Content-Type: application/json" \\
  ${deploymentConfig.apiKey?.enabled ? '-H "X-API-Key: your-api-key" \\' : ''}
  -d '{
    "variables": {
${promptConfig.variables.map(v => `      "${v.name}": "value"`).join(',\n')}
    }
  }'
\`\`\`

### Get Prompt Info

\`\`\`bash
curl https://your-api-id.execute-api.${deploymentConfig.region}.amazonaws.com/Prod/prompt
\`\`\`

## Features

- ✅ ARM64 architecture for better performance
- ✅ API Gateway integration
- ✅ CloudWatch Logs
${deploymentConfig.rateLimit?.enabled ? '- ✅ Rate limiting' : ''}
${deploymentConfig.webhook?.enabled ? '- ✅ Webhook notifications' : ''}
${deploymentConfig.apiKey?.enabled ? '- ✅ API key authentication' : ''}
`;

  return {
    files: {
      'src/handler.ts': handlerCode,
      'template.yaml': samTemplate,
      'package.json': packageJson,
      'tsconfig.json': tsconfig,
      'samconfig.toml': samconfig,
    },
    readme,
    deployCommand: 'sam build && sam deploy --guided',
  };
}
