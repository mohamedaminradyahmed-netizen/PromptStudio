import { PromptConfig, DeploymentConfig } from '@/types';
import { DeploymentFiles } from './index';

function escapeString(str: string): string {
  return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
}

export function generateGCPFunctionsDeployment(
  promptConfig: PromptConfig,
  deploymentConfig: DeploymentConfig
): DeploymentFiles {
  const promptTemplate = escapeString(promptConfig.prompt);

  const handlerCode = `/**
 * ${promptConfig.name} - Google Cloud Function
 * Generated by PromptStudio
 */

import { HttpFunction } from '@google-cloud/functions-framework';
import { SecretManagerServiceClient } from '@google-cloud/secret-manager';

// Prompt configuration
const PROMPT_TEMPLATE = \`${promptTemplate}\`;
const DEFAULT_MODEL = '${promptConfig.model}';
const DEFAULT_CONFIG = {
  temperature: ${promptConfig.temperature},
  max_tokens: ${promptConfig.maxTokens},
  top_p: ${promptConfig.topP},
  frequency_penalty: ${promptConfig.frequencyPenalty},
  presence_penalty: ${promptConfig.presencePenalty},
};

interface PromptVariables {
${promptConfig.variables.map(v => `  ${v.name}${v.required ? '' : '?'}: ${v.type === 'string' ? 'string' : v.type === 'number' ? 'number' : v.type === 'boolean' ? 'boolean' : 'unknown'};`).join('\n')}
}

interface RequestBody {
  variables?: PromptVariables;
  options?: {
    model?: string;
    temperature?: number;
    max_tokens?: number;
    top_p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
  };
}

function buildPrompt(variables: Record<string, unknown>): string {
  let prompt = PROMPT_TEMPLATE;
  for (const [key, value] of Object.entries(variables)) {
    prompt = prompt.replace(new RegExp(\`{{\\\\s*\${key}\\\\s*}}\`, 'g'), String(value));
  }
  return prompt;
}

// Secret Manager client for retrieving secrets
const secretClient = new SecretManagerServiceClient();

async function getSecret(secretName: string): Promise<string> {
  const projectId = process.env.GCP_PROJECT || process.env.GCLOUD_PROJECT;
  const name = \`projects/\${projectId}/secrets/\${secretName}/versions/latest\`;

  try {
    const [version] = await secretClient.accessSecretVersion({ name });
    return version.payload?.data?.toString() || '';
  } catch (error) {
    console.error(\`Error accessing secret \${secretName}:\`, error);
    return process.env[secretName.toUpperCase().replace(/-/g, '_')] || '';
  }
}

${deploymentConfig.rateLimit?.enabled ? `
// Simple in-memory rate limiting (for production, use Firestore or Redis)
const rateLimitStore = new Map<string, { count: number; resetAt: number }>();

function checkRateLimit(clientId: string): { allowed: boolean; retryAfter?: number } {
  const now = Date.now();
  const windowMs = 60000;
  const maxRequests = ${deploymentConfig.rateLimit.requestsPerMinute};

  const record = rateLimitStore.get(clientId);

  if (!record || now > record.resetAt) {
    rateLimitStore.set(clientId, { count: 1, resetAt: now + windowMs });
    return { allowed: true };
  }

  if (record.count >= maxRequests) {
    return { allowed: false, retryAfter: Math.ceil((record.resetAt - now) / 1000) };
  }

  record.count++;
  return { allowed: true };
}
` : ''}

${deploymentConfig.webhook?.enabled ? `
import * as crypto from 'crypto';

async function sendWebhook(event: string, data: Record<string, unknown>): Promise<void> {
  const webhookUrl = process.env.WEBHOOK_URL || await getSecret('webhook-url');
  const webhookSecret = process.env.WEBHOOK_SECRET || await getSecret('webhook-secret');

  if (!webhookUrl) return;

  try {
    const payload = JSON.stringify({
      event,
      timestamp: new Date().toISOString(),
      data,
    });

    const signature = crypto
      .createHmac('sha256', webhookSecret)
      .update(payload)
      .digest('base64');

    await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': signature,
      },
      body: payload,
    });
  } catch (error) {
    console.error('Webhook error:', error);
  }
}
` : ''}

${deploymentConfig.apiKey?.enabled ? `
async function validateApiKey(apiKey: string | undefined): Promise<boolean> {
  if (!apiKey) return false;
  const validKeysStr = process.env.API_KEYS || await getSecret('api-keys');
  const validKeys = validKeysStr.split(',').filter(Boolean);
  return validKeys.length === 0 || validKeys.includes(apiKey);
}
` : ''}

export const promptHandler: HttpFunction = async (req, res) => {
  // Set CORS headers
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-API-Key');

  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  // GET - Return prompt info
  if (req.method === 'GET') {
    res.json({
      name: '${promptConfig.name}',
      description: '${promptConfig.description || ''}',
      model: DEFAULT_MODEL,
      variables: ${JSON.stringify(promptConfig.variables.map(v => ({
        name: v.name,
        type: v.type,
        required: v.required,
        description: v.description
      })))},
    });
    return;
  }

  // POST - Execute prompt
  if (req.method === 'POST') {
    const startTime = Date.now();

    try {
      ${deploymentConfig.apiKey?.enabled ? `
      // Validate API key
      const apiKey = req.headers['x-api-key'] as string ||
                     (req.headers['authorization'] as string)?.replace('Bearer ', '');
      if (!(await validateApiKey(apiKey))) {
        res.status(401).json({ error: 'Invalid or missing API key' });
        return;
      }
      ` : ''}

      ${deploymentConfig.rateLimit?.enabled ? `
      // Check rate limit
      const clientId = req.ip || 'anonymous';
      const { allowed, retryAfter } = checkRateLimit(clientId);

      if (!allowed) {
        ${deploymentConfig.webhook?.enabled ? `await sendWebhook('rate_limit.exceeded', { clientId });` : ''}
        res.set('Retry-After', String(retryAfter));
        res.status(429).json({ error: 'Rate limit exceeded' });
        return;
      }
      ` : ''}

      const body: RequestBody = req.body || {};
      const { variables = {}, options = {} } = body;

      ${deploymentConfig.webhook?.enabled ? `await sendWebhook('request.started', { variables });` : ''}

      const prompt = buildPrompt(variables);

      const payload = {
        model: options.model || DEFAULT_MODEL,
        messages: [{ role: 'user', content: prompt }],
        ...DEFAULT_CONFIG,
        ...options,
      };

      // Get OpenAI API key from Secret Manager or environment
      const openaiApiKey = process.env.OPENAI_API_KEY || await getSecret('openai-api-key');

      const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': \`Bearer \${openaiApiKey}\`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!openaiResponse.ok) {
        const error = await openaiResponse.json() as Record<string, unknown>;
        ${deploymentConfig.webhook?.enabled ? `await sendWebhook('request.failed', { error });` : ''}
        res.status(openaiResponse.status).json({
          error: (error.error as Record<string, unknown>)?.message || 'OpenAI API error'
        });
        return;
      }

      const data = await openaiResponse.json() as Record<string, unknown>;
      const latencyMs = Date.now() - startTime;

      const choices = data.choices as Array<Record<string, unknown>>;
      const usage = data.usage as Record<string, number>;

      const response = {
        content: (choices?.[0]?.message as Record<string, unknown>)?.content || '',
        model: data.model,
        usage: {
          promptTokens: usage?.prompt_tokens || 0,
          completionTokens: usage?.completion_tokens || 0,
          totalTokens: usage?.total_tokens || 0,
        },
        finishReason: choices?.[0]?.finish_reason || '',
        latencyMs,
      };

      ${deploymentConfig.webhook?.enabled ? `await sendWebhook('request.completed', { latencyMs, usage: response.usage });` : ''}

      res.json(response);
    } catch (error) {
      console.error('Error:', error);
      ${deploymentConfig.webhook?.enabled ? `await sendWebhook('error.occurred', { error: String(error) });` : ''}
      res.status(500).json({ error: 'Internal server error' });
    }
    return;
  }

  res.status(405).json({ error: 'Method not allowed' });
};
`;

  const packageJson = `{
  "name": "${deploymentConfig.name}",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "deploy": "npm run build && gcloud functions deploy ${deploymentConfig.name} --gen2 --runtime=nodejs20 --region=${deploymentConfig.region} --source=. --entry-point=promptHandler --trigger-http --allow-unauthenticated --memory=${deploymentConfig.memory}MB --timeout=${deploymentConfig.timeout}s",
    "local": "npx @google-cloud/functions-framework --target=promptHandler"
  },
  "dependencies": {
    "@google-cloud/functions-framework": "^3.3.0",
    "@google-cloud/secret-manager": "^5.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}`;

  const tsconfig = `{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}`;

  const gcloudIgnore = `node_modules/
src/
*.ts
!dist/
tsconfig.json
.git
.gitignore
`;

  const readme = `# ${promptConfig.name} - Google Cloud Function

This API endpoint is deployed on Google Cloud Functions (2nd gen).

## Prerequisites

- Google Cloud SDK (gcloud) installed and configured
- A GCP project with Cloud Functions API enabled

## Setup

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Create secrets in Secret Manager:
   \`\`\`bash
   # Create the OpenAI API key secret
   echo -n "your-openai-api-key" | gcloud secrets create openai-api-key --data-file=-

   ${deploymentConfig.webhook?.enabled ? `# Create webhook secrets
   echo -n "your-webhook-url" | gcloud secrets create webhook-url --data-file=-
   echo -n "your-webhook-secret" | gcloud secrets create webhook-secret --data-file=-` : ''}

   ${deploymentConfig.apiKey?.enabled ? `# Create API keys secret
   echo -n "key1,key2,key3" | gcloud secrets create api-keys --data-file=-` : ''}
   \`\`\`

3. Grant the Cloud Function access to secrets:
   \`\`\`bash
   gcloud secrets add-iam-policy-binding openai-api-key \\
     --member="serviceAccount:YOUR-PROJECT-ID@appspot.gserviceaccount.com" \\
     --role="roles/secretmanager.secretAccessor"
   \`\`\`

## Deployment

Build and deploy:
\`\`\`bash
npm run deploy
\`\`\`

Or set environment variables directly:
\`\`\`bash
npm run build && gcloud functions deploy ${deploymentConfig.name} \\
  --gen2 \\
  --runtime=nodejs20 \\
  --region=${deploymentConfig.region} \\
  --source=. \\
  --entry-point=promptHandler \\
  --trigger-http \\
  --allow-unauthenticated \\
  --memory=${deploymentConfig.memory}MB \\
  --timeout=${deploymentConfig.timeout}s \\
  --set-env-vars="OPENAI_API_KEY=your-key"
\`\`\`

## Local Development

Run the function locally:
\`\`\`bash
OPENAI_API_KEY=your-key npm run local
\`\`\`

## Usage

### Execute Prompt

\`\`\`bash
curl -X POST https://${deploymentConfig.region}-YOUR-PROJECT-ID.cloudfunctions.net/${deploymentConfig.name} \\
  -H "Content-Type: application/json" \\
  ${deploymentConfig.apiKey?.enabled ? '-H "X-API-Key: your-api-key" \\' : ''}
  -d '{
    "variables": {
${promptConfig.variables.map(v => `      "${v.name}": "value"`).join(',\n')}
    }
  }'
\`\`\`

### Get Prompt Info

\`\`\`bash
curl https://${deploymentConfig.region}-YOUR-PROJECT-ID.cloudfunctions.net/${deploymentConfig.name}
\`\`\`

## Features

- ✅ 2nd gen Cloud Functions (Cloud Run based)
- ✅ Secret Manager integration
- ✅ Cloud Logging
${deploymentConfig.rateLimit?.enabled ? '- ✅ Rate limiting' : ''}
${deploymentConfig.webhook?.enabled ? '- ✅ Webhook notifications' : ''}
${deploymentConfig.apiKey?.enabled ? '- ✅ API key authentication' : ''}
`;

  return {
    files: {
      'src/index.ts': handlerCode,
      'package.json': packageJson,
      'tsconfig.json': tsconfig,
      '.gcloudignore': gcloudIgnore,
    },
    readme,
    deployCommand: `gcloud functions deploy ${deploymentConfig.name} --gen2 --runtime=nodejs20 --region=${deploymentConfig.region} --source=. --entry-point=promptHandler --trigger-http --allow-unauthenticated`,
  };
}
