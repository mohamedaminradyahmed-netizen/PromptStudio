import { PromptConfig, DeploymentConfig } from '@/types';
import { DeploymentFiles } from './index';

function escapeString(str: string): string {
  return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
}

export function generateCloudflareDeployment(
  promptConfig: PromptConfig,
  deploymentConfig: DeploymentConfig
): DeploymentFiles {
  const promptTemplate = escapeString(promptConfig.prompt);

  const workerCode = `/**
 * ${promptConfig.name} - Cloudflare Worker
 * Generated by PromptStudio
 */

export interface Env {
  OPENAI_API_KEY: string;
  ${deploymentConfig.webhook?.enabled ? 'WEBHOOK_URL: string;' : ''}
  ${deploymentConfig.webhook?.enabled ? 'WEBHOOK_SECRET: string;' : ''}
  ${deploymentConfig.apiKey?.enabled ? 'API_KEYS: string;' : ''}
  ${deploymentConfig.rateLimit?.enabled ? 'RATE_LIMIT_KV: KVNamespace;' : ''}
}

// Prompt configuration
const PROMPT_TEMPLATE = \`${promptTemplate}\`;
const DEFAULT_MODEL = '${promptConfig.model}';
const DEFAULT_CONFIG = {
  temperature: ${promptConfig.temperature},
  max_tokens: ${promptConfig.maxTokens},
  top_p: ${promptConfig.topP},
  frequency_penalty: ${promptConfig.frequencyPenalty},
  presence_penalty: ${promptConfig.presencePenalty},
};

interface PromptVariables {
${promptConfig.variables.map(v => `  ${v.name}${v.required ? '' : '?'}: ${v.type === 'string' ? 'string' : v.type === 'number' ? 'number' : v.type === 'boolean' ? 'boolean' : 'unknown'};`).join('\n')}
}

interface RequestBody {
  variables?: PromptVariables;
  options?: {
    model?: string;
    temperature?: number;
    max_tokens?: number;
    top_p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
  };
}

function buildPrompt(variables: Record<string, unknown>): string {
  let prompt = PROMPT_TEMPLATE;
  for (const [key, value] of Object.entries(variables)) {
    prompt = prompt.replace(new RegExp(\`{{\\\\s*\${key}\\\\s*}}\`, 'g'), String(value));
  }
  return prompt;
}

${deploymentConfig.rateLimit?.enabled ? `
async function checkRateLimit(env: Env, clientId: string): Promise<{ allowed: boolean; retryAfter?: number }> {
  const key = \`rate_limit:\${clientId}\`;
  const windowMs = 60000;
  const maxRequests = ${deploymentConfig.rateLimit.requestsPerMinute};

  const data = await env.RATE_LIMIT_KV.get(key, 'json') as { count: number; resetAt: number } | null;
  const now = Date.now();

  if (!data || now > data.resetAt) {
    await env.RATE_LIMIT_KV.put(key, JSON.stringify({ count: 1, resetAt: now + windowMs }), {
      expirationTtl: 120
    });
    return { allowed: true };
  }

  if (data.count >= maxRequests) {
    return { allowed: false, retryAfter: Math.ceil((data.resetAt - now) / 1000) };
  }

  await env.RATE_LIMIT_KV.put(key, JSON.stringify({ count: data.count + 1, resetAt: data.resetAt }), {
    expirationTtl: 120
  });
  return { allowed: true };
}
` : ''}

${deploymentConfig.webhook?.enabled ? `
async function sendWebhook(env: Env, event: string, data: Record<string, unknown>): Promise<void> {
  if (!env.WEBHOOK_URL) return;

  try {
    const payload = JSON.stringify({
      event,
      timestamp: new Date().toISOString(),
      data,
    });

    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      'raw',
      encoder.encode(env.WEBHOOK_SECRET || ''),
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );

    const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(payload));
    const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)));

    await fetch(env.WEBHOOK_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Signature': signatureBase64,
      },
      body: payload,
    });
  } catch (error) {
    console.error('Webhook error:', error);
  }
}
` : ''}

${deploymentConfig.apiKey?.enabled ? `
function validateApiKey(request: Request, env: Env): boolean {
  const apiKey = request.headers.get('x-api-key') ||
                 request.headers.get('authorization')?.replace('Bearer ', '');
  const validKeys = (env.API_KEYS || '').split(',').filter(Boolean);
  return validKeys.length === 0 || validKeys.includes(apiKey || '');
}
` : ''}

function corsHeaders(): HeadersInit {
  return {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Key',
  };
}

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders() });
    }

    const url = new URL(request.url);

    // GET - Return prompt info
    if (request.method === 'GET') {
      return new Response(JSON.stringify({
        name: '${promptConfig.name}',
        description: '${promptConfig.description || ''}',
        model: DEFAULT_MODEL,
        variables: ${JSON.stringify(promptConfig.variables.map(v => ({
          name: v.name,
          type: v.type,
          required: v.required,
          description: v.description
        })))},
      }), {
        headers: { ...corsHeaders(), 'Content-Type': 'application/json' },
      });
    }

    // POST - Execute prompt
    if (request.method === 'POST') {
      const startTime = Date.now();

      try {
        ${deploymentConfig.apiKey?.enabled ? `
        // Validate API key
        if (!validateApiKey(request, env)) {
          return new Response(JSON.stringify({ error: 'Invalid or missing API key' }), {
            status: 401,
            headers: { ...corsHeaders(), 'Content-Type': 'application/json' },
          });
        }
        ` : ''}

        ${deploymentConfig.rateLimit?.enabled ? `
        // Check rate limit
        const clientId = request.headers.get('cf-connecting-ip') || 'anonymous';
        const { allowed, retryAfter } = await checkRateLimit(env, clientId);

        if (!allowed) {
          ${deploymentConfig.webhook?.enabled ? `ctx.waitUntil(sendWebhook(env, 'rate_limit.exceeded', { clientId }));` : ''}
          return new Response(JSON.stringify({ error: 'Rate limit exceeded' }), {
            status: 429,
            headers: {
              ...corsHeaders(),
              'Content-Type': 'application/json',
              'Retry-After': String(retryAfter),
            },
          });
        }
        ` : ''}

        const body: RequestBody = await request.json();
        const { variables = {}, options = {} } = body;

        ${deploymentConfig.webhook?.enabled ? `ctx.waitUntil(sendWebhook(env, 'request.started', { variables }));` : ''}

        const prompt = buildPrompt(variables);

        const payload = {
          model: options.model || DEFAULT_MODEL,
          messages: [{ role: 'user', content: prompt }],
          ...DEFAULT_CONFIG,
          ...options,
        };

        const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': \`Bearer \${env.OPENAI_API_KEY}\`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        });

        if (!openaiResponse.ok) {
          const error = await openaiResponse.json() as Record<string, unknown>;
          ${deploymentConfig.webhook?.enabled ? `ctx.waitUntil(sendWebhook(env, 'request.failed', { error }));` : ''}
          return new Response(JSON.stringify({
            error: (error.error as Record<string, unknown>)?.message || 'OpenAI API error'
          }), {
            status: openaiResponse.status,
            headers: { ...corsHeaders(), 'Content-Type': 'application/json' },
          });
        }

        const data = await openaiResponse.json() as Record<string, unknown>;
        const latencyMs = Date.now() - startTime;

        const choices = data.choices as Array<Record<string, unknown>>;
        const usage = data.usage as Record<string, number>;

        const response = {
          content: (choices?.[0]?.message as Record<string, unknown>)?.content || '',
          model: data.model,
          usage: {
            promptTokens: usage?.prompt_tokens || 0,
            completionTokens: usage?.completion_tokens || 0,
            totalTokens: usage?.total_tokens || 0,
          },
          finishReason: choices?.[0]?.finish_reason || '',
          latencyMs,
        };

        ${deploymentConfig.webhook?.enabled ? `ctx.waitUntil(sendWebhook(env, 'request.completed', { latencyMs, usage: response.usage }));` : ''}

        return new Response(JSON.stringify(response), {
          headers: { ...corsHeaders(), 'Content-Type': 'application/json' },
        });
      } catch (error) {
        ${deploymentConfig.webhook?.enabled ? `ctx.waitUntil(sendWebhook(env, 'error.occurred', { error: String(error) }));` : ''}
        return new Response(JSON.stringify({ error: 'Internal server error' }), {
          status: 500,
          headers: { ...corsHeaders(), 'Content-Type': 'application/json' },
        });
      }
    }

    return new Response('Method not allowed', { status: 405 });
  },
};
`;

  const wranglerToml = `name = "${deploymentConfig.name}"
main = "src/worker.ts"
compatibility_date = "2024-01-01"

${deploymentConfig.rateLimit?.enabled ? `
[[kv_namespaces]]
binding = "RATE_LIMIT_KV"
id = "your-kv-namespace-id"
` : ''}

[vars]
# Set secrets using: wrangler secret put OPENAI_API_KEY
`;

  const packageJson = `{
  "name": "${deploymentConfig.name}",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "tail": "wrangler tail"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20231218.0",
    "typescript": "^5.0.0",
    "wrangler": "^3.22.0"
  }
}`;

  const tsconfig = `{
  "compilerOptions": {
    "target": "ES2021",
    "module": "ESNext",
    "moduleResolution": "node",
    "lib": ["ES2021"],
    "types": ["@cloudflare/workers-types"],
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts"]
}`;

  const readme = `# ${promptConfig.name} - Cloudflare Worker

This API endpoint is deployed on Cloudflare's global edge network.

## Deployment

1. Install Wrangler CLI:
   \`\`\`bash
   npm install -g wrangler
   \`\`\`

2. Login to Cloudflare:
   \`\`\`bash
   wrangler login
   \`\`\`

${deploymentConfig.rateLimit?.enabled ? `3. Create KV namespace for rate limiting:
   \`\`\`bash
   wrangler kv:namespace create "RATE_LIMIT_KV"
   \`\`\`
   Update the namespace ID in wrangler.toml

` : ''}3. Set secrets:
   \`\`\`bash
   wrangler secret put OPENAI_API_KEY
   ${deploymentConfig.webhook?.enabled ? 'wrangler secret put WEBHOOK_URL\nwrangler secret put WEBHOOK_SECRET' : ''}
   ${deploymentConfig.apiKey?.enabled ? 'wrangler secret put API_KEYS' : ''}
   \`\`\`

4. Deploy:
   \`\`\`bash
   npm run deploy
   \`\`\`

## Usage

### Execute Prompt

\`\`\`bash
curl -X POST https://${deploymentConfig.name}.your-subdomain.workers.dev \\
  -H "Content-Type: application/json" \\
  ${deploymentConfig.apiKey?.enabled ? '-H "X-API-Key: your-api-key" \\' : ''}
  -d '{
    "variables": {
${promptConfig.variables.map(v => `      "${v.name}": "value"`).join(',\n')}
    }
  }'
\`\`\`

### Get Prompt Info

\`\`\`bash
curl https://${deploymentConfig.name}.your-subdomain.workers.dev
\`\`\`

## Features

- ✅ 0ms cold start time
- ✅ 300+ edge locations worldwide
${deploymentConfig.rateLimit?.enabled ? '- ✅ Rate limiting with KV storage' : ''}
${deploymentConfig.webhook?.enabled ? '- ✅ Webhook notifications' : ''}
${deploymentConfig.apiKey?.enabled ? '- ✅ API key authentication' : ''}
`;

  return {
    files: {
      'src/worker.ts': workerCode,
      'wrangler.toml': wranglerToml,
      'package.json': packageJson,
      'tsconfig.json': tsconfig,
    },
    readme,
    deployCommand: 'wrangler deploy',
  };
}
